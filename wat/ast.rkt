#lang racket

(provide (all-defined-out))

;; type Module = (Module (Listof definitions))
(struct Module (ds) #:prefab)
;; type Import = (Import (modulename funcname FuncSignature)) 
(struct Import (m f fs) #:prefab)
;; type Export = (Export (name ExportFuncSignature))
(struct Export (n d) #:prefab)
;; type Func = (Func (FuncSignature (Listof Locals) Body))
(struct Func (s ls b) #:prefab)
;; type FuncSignature = (FuncSignature (name? (Listof Params) Result))
(struct FuncSignature (n ps r) #:prefab)
;; type ExportFuncSignature = (ExportFuncSignature (name))
(struct ExportFuncSignature (n) #:prefab)
;; type Param = (Param (name? Type))
(struct Param (n t) #:prefab)
;; type Result = (Result (Type))
(struct Result (t) #:prefab)
;; type Local = (Local (name? Type))
(struct Local (n t) #:prefab)
;; type Type = i32 | i64 | f32 | f64
(struct i32 () #:prefab)
(struct i64 () #:prefab)
(struct f32 () #:prefab)
(struct f64 () #:prefab)
;; type Body = (Body (Listof Instructions))
(struct Body (is) #:prefab)
;; type Instruction = (Inst (n [list of Instructions]))
(struct Inst (n is) #:prefab)
;; type Name = (Name (n))
(struct Name (n) #:prefab)
;; type Const = (Const (n))
(struct Const (n) #:prefab)
;; type Start = (Start (funcidx))
(struct Start (f) #:prefab)

;; (U Instruction Asm) ... -> Asm
;; Convenient for sequencing instructions or groups of instructions
(define (seq . xs)
  (foldr (Î» (x is)
           (if (list? x)
               (append x is)
               (cons x is)))
         '()
         xs))